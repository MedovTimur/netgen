use std::net::SocketAddr;
use std::sync::Arc;

use anyhow::Result;
use tokio::io::{AsyncBufReadExt, AsyncReadExt, AsyncWriteExt, BufReader};
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::{mpsc, Mutex};

{{#if tracing_enabled}}
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
{{/if}}

#[derive(Debug)]
struct ServerEvent {
    peer: SocketAddr,
    len: usize,
}

fn start_worker_pool(rx: Arc<Mutex<mpsc::Receiver<ServerEvent>>>, workers: usize) {
    for worker_id in 0..workers {
        let rx = Arc::clone(&rx);
        tokio::spawn(async move {
            loop {
                let msg = {
                    let mut guard = rx.lock().await;
                    guard.recv().await
                };
                match msg {
                    Some(ev) => {
                        {{#if tracing_enabled}}
                        tracing::info!(
                            "[worker {}] processed message from {} (len={})",
                            worker_id,
                            ev.peer,
                            ev.len
                        );
                        {{else}}
                        println!(
                            "[worker {}] processed message from {} (len={})",
                            worker_id,
                            ev.peer,
                            ev.len
                        );
                        {{/if}}
                    }
                    None => {
                        {{#if tracing_enabled}}
                        tracing::info!("[worker {}] channel closed, shutting down", worker_id);
                        {{else}}
                        println!("[worker {}] channel closed, shutting down", worker_id);
                        {{/if}}
                        break;
                    }
                }
            }
        });
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    {{#if tracing_enabled}}
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "info".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();
    {{/if}}

    let addr = SocketAddr::from(([0, 0, 0, 0], {{port}}));
    let listener = TcpListener::bind(addr).await?;
    {{#if tracing_enabled}}
    tracing::info!(
        "TCP worker-pool server listening on {} (workers = {}, buffer = {})",
        addr,
        {{workers}},
        {{event_buffer}}
    );
    {{else}}
    println!(
        "TCP worker-pool server listening on {} (workers = {}, buffer = {})",
        addr,
        {{workers}},
        {{event_buffer}}
    );
    {{/if}}

    let (tx, rx) = mpsc::channel::<ServerEvent>({{event_buffer}});
    let rx = Arc::new(Mutex::new(rx));

    start_worker_pool(Arc::clone(&rx), {{workers}});

    loop {
        let (socket, peer_addr) = listener.accept().await?;
        {{#if tracing_enabled}}
        tracing::info!("accepted connection from {}", peer_addr);
        {{else}}
        println!("accepted connection from {}", peer_addr);
        {{/if}}

        let tx_clone = tx.clone();
        tokio::spawn(async move {
            if let Err(err) = handle_client(socket, peer_addr, tx_clone).await {
                {{#if tracing_enabled}}
                tracing::warn!("error handling client {}: {:?}", peer_addr, err);
                {{else}}
                eprintln!("error handling client {}: {:?}", peer_addr, err);
                {{/if}}
            }
        });
    }
}

{{!-- ===== read_mode = lines ===== --}}
{{#if is_lines}}
async fn handle_client(
    socket: TcpStream,
    peer_addr: SocketAddr,
    tx: mpsc::Sender<ServerEvent>,
) -> Result<()> {
    let (reader, mut writer) = socket.into_split();
    let mut reader = BufReader::new(reader);
    let mut buf = String::new();

    loop {
        buf.clear();
        let n = reader.read_line(&mut buf).await?;
        if n == 0 {
            {{#if tracing_enabled}}
            tracing::info!("client {} disconnected", peer_addr);
            {{else}}
            println!("client {} disconnected", peer_addr);
            {{/if}}
            break;
        }

        {{#if max_line_len}}
        if buf.len() > {{max_line_len}} {
            {{#if tracing_enabled}}
            tracing::warn!(
                "line from {} exceeded max_len = {}, truncating",
                peer_addr,
                {{max_line_len}}
            );
            {{else}}
            eprintln!(
                "line from {} exceeded max_len = {}, truncating",
                peer_addr,
                {{max_line_len}}
            );
            {{/if}}
            buf.truncate({{max_line_len}});
        }
        {{/if}}

        let frame_len = buf.len();
        writer.write_all(buf.as_bytes()).await?;

        if let Err(err) = tx
            .send(ServerEvent {
                peer: peer_addr,
                len: frame_len,
            })
            .await
        {
            {{#if tracing_enabled}}
            tracing::warn!("failed to send event to workers: {:?}", err);
            {{else}}
            eprintln!("failed to send event to workers: {:?}", err);
            {{/if}}
            break;
        }
    }

    Ok(())
}
{{/if}}

{{!-- ===== read_mode = fixed_size ===== --}}
{{#if is_fixed_size}}
async fn handle_client(
    socket: TcpStream,
    peer_addr: SocketAddr,
    tx: mpsc::Sender<ServerEvent>,
) -> Result<()> {
    use std::io::ErrorKind;

    let (mut reader, mut writer) = socket.into_split();
    let mut buf = vec![0u8; {{frame_size}}];

    loop {
        match reader.read_exact(&mut buf).await {
            Ok(_) => {
                let frame_len = buf.len();
                writer.write_all(&buf).await?;

                if let Err(err) = tx
                    .send(ServerEvent {
                        peer: peer_addr,
                        len: frame_len,
                    })
                    .await
                {
                    {{#if tracing_enabled}}
                    tracing::warn!("failed to send event to workers: {:?}", err);
                    {{else}}
                    eprintln!("failed to send event to workers: {:?}", err);
                    {{/if}}
                    break;
                }
            }
            Err(err) => {
                match err.kind() {
                    ErrorKind::UnexpectedEof => {
                        {{#if tracing_enabled}}
                        tracing::info!("client {} disconnected (EOF)", peer_addr);
                        {{else}}
                        println!("client {} disconnected (EOF)", peer_addr);
                        {{/if}}
                    }
                    _ => {
                        {{#if tracing_enabled}}
                        tracing::warn!(
                            "client {} error during read_exact: {:?}",
                            peer_addr,
                            err
                        );
                        {{else}}
                        eprintln!(
                            "client {} error during read_exact: {:?}",
                            peer_addr,
                            err
                        );
                        {{/if}}
                    }
                }
                break;
            }
        }
    }

    Ok(())
}
{{/if}}

{{!-- ===== read_mode = delimited ===== --}}
{{#if is_delimited}}
async fn handle_client(
    socket: TcpStream,
    peer_addr: SocketAddr,
    tx: mpsc::Sender<ServerEvent>,
) -> Result<()> {
    let (reader, mut writer) = socket.into_split();
    let mut reader = BufReader::new(reader);
    let mut buf = Vec::new();
    let delim: u8 = {{delim_byte}};

    loop {
        buf.clear();
        let n = reader.read_until(delim, &mut buf).await?;
        if n == 0 {
            {{#if tracing_enabled}}
            tracing::info!("client {} disconnected", peer_addr);
            {{else}}
            println!("client {} disconnected", peer_addr);
            {{/if}}
            break;
        }

        {{#if delim_max_len}}
        if buf.len() > {{delim_max_len}} {
            {{#if tracing_enabled}}
            tracing::warn!(
                "frame from {} exceeded max_len = {}, truncating",
                peer_addr,
                {{delim_max_len}}
            );
            {{else}}
            eprintln!(
                "frame from {} exceeded max_len = {}, truncating",
                peer_addr,
                {{delim_max_len}}
            );
            {{/if}}
            buf.truncate({{delim_max_len}});
        }
        {{/if}}

        let frame_len = buf.len();
        writer.write_all(&buf).await?;

        if let Err(err) = tx
            .send(ServerEvent {
                peer: peer_addr,
                len: frame_len,
            })
            .await
        {
            {{#if tracing_enabled}}
            tracing::warn!("failed to send event to workers: {:?}", err);
            {{else}}
            eprintln!("failed to send event to workers: {:?}", err);
            {{/if}}
            break;
        }
    }

    Ok(())
}
{{/if}}

{{!-- ===== read_mode = length_prefixed ===== --}}
{{#if is_length_prefixed}}
async fn handle_client(
    socket: TcpStream,
    peer_addr: SocketAddr,
    tx: mpsc::Sender<ServerEvent>,
) -> Result<()> {
    let (mut reader, mut writer) = socket.into_split();

    loop {
        let mut len_buf = vec![0u8; {{lp_len_bytes}}];

        if let Err(err) = reader.read_exact(&mut len_buf).await {
            {{#if tracing_enabled}}
            tracing::info!(
                "client {} disconnected while reading length: {:?}",
                peer_addr,
                err
            );
            {{else}}
            println!(
                "client {} disconnected while reading length: {:?}",
                peer_addr,
                err
            );
            {{/if}}
            break;
        }

        {{lp_parse_len_code}}

        if frame_len == 0 {
            continue;
        }

        {{#if lp_max_len}}
        if frame_len > {{lp_max_len}} {
            {{#if tracing_enabled}}
            tracing::warn!(
                "frame from {} has len={} exceeding max_len={}, closing",
                peer_addr,
                frame_len,
                {{lp_max_len}}
            );
            {{else}}
            eprintln!(
                "frame from {} has len={} exceeding max_len={}, closing",
                peer_addr,
                frame_len,
                {{lp_max_len}}
            );
            {{/if}}
            break;
        }
        {{/if}}

        let mut buf = vec![0u8; frame_len];
        if let Err(err) = reader.read_exact(&mut buf).await {
            {{#if tracing_enabled}}
            tracing::info!(
                "client {} disconnected while reading frame: {:?}",
                peer_addr,
                err
            );
            {{else}}
            println!(
                "client {} disconnected while reading frame: {:?}",
                peer_addr,
                err
            );
            {{/if}}
            break;
        }

        writer.write_all(&buf).await?;

        if let Err(err) = tx
            .send(ServerEvent {
                peer: peer_addr,
                len: frame_len,
            })
            .await
        {
            {{#if tracing_enabled}}
            tracing::warn!("failed to send event to workers: {:?}", err);
            {{else}}
            eprintln!("failed to send event to workers: {:?}", err);
            {{/if}}
            break;
        }
    }

    Ok(())
}
{{/if}}
